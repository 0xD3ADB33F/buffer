# Go Buffer #

### What is this repository for? ###

* Implements a bunch of different types of buffers in go, including: bounded, unbounded, memory based, file based, and more!
* Version 0.1

### How do I get set up? ###

go get github.com/djherbis/buffer

### Why Buffers? ####

The following buffers provide simple unique behviours which when composed can create complex buffering strategies. For use with github.com/djherbis/nio for Buffered io.Pipe and io.Copy implementations.

For example: 

NewUnboundedBuffer(mem, chunk) = NewMulti(New(mem), NewPartition(func() Buffer { return NewFile(chunk) }))
Buffers mem bytes to Memory, then creates Files with max-size chunk for overflow.

Spill(New(mem), ioutil.Discard), a leaky buffer. When its memory is full it discards the extra.

etc.

### Supported Buffers ###

#### Bounded Buffers ####

Memory: Wrapper for bytes.Buffer

File: File-based buffering. The file never exceeds Cap() in length, no matter how many times its written/read from. It accomplishes this by "wrapping" around the fixed max-length file when the data gets too long but there is available freed space at the beginning of the file. The file deletes itself when empty.

Multi: A fixed length linked-list of buffers. Each buffer reads from the next buffer so that all the buffered data is shifted upwards in the list when reading. Writes are always written to the first buffer in the list whose Len() < Cap().

#### Unbounded Buffers ####

Partition: A queue of buffers. Writes always go to the first buffer in the queue which isn't full. If all buffers are full, a new buffer is "pushed" to the end of the queue (generated by a user-given function). Reads come from the first buffer, when the first buffer is emptied it is "poped" off the queue.

Ring: A single buffer which begins overwriting the oldest buffered data when it reaches its capacity.

Spill: A single buffer which when full, writes the overflow to a given io.Writer.
-> Note that it will actually "spill" whenever there is an error while writing, this should only be a "full" error.

#### Empty Buffer ####

Discard: Reads always return EOF, writes goto ioutil.Discard.