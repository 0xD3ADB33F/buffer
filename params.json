{"name":"Buffer","tagline":"Composable Buffers for Go #golang","body":"Buffer \r\n==========\r\n\r\n[![GoDoc](https://godoc.org/github.com/djherbis/buffer?status.svg)](https://godoc.org/github.com/djherbis/buffer)\r\n[![Software License](https://img.shields.io/badge/license-MIT-brightgreen.svg)](LICENSE.txt)\r\n[![Build Status](https://travis-ci.org/djherbis/buffer.svg?branch=master)](https://travis-ci.org/djherbis/buffer) \r\n[![Coverage Status](https://coveralls.io/repos/djherbis/buffer/badge.svg?branch=master)](https://coveralls.io/r/djherbis/buffer?branch=master)\r\n\r\nUsage\r\n------------\r\n\r\nThe following buffers provide simple unique behaviours which when composed can create complex buffering strategies. For use with github.com/djherbis/nio for Buffered io.Pipe and io.Copy implementations.\r\n\r\nFor example: \r\n\r\n```go\r\nimport (\r\n  \"github.com/djherbis/buffer\"\r\n  \"github.com/djherbis/nio\"\r\n  \r\n  \"io/ioutil\"\r\n)\r\n\r\n// Buffer 32KB to Memory, after that buffer to 100MB chunked files\r\nbuf := buffer.NewUnboundedBuffer(32*1024, 100*1024*1024)\r\nnio.Copy(w, r, buf) // Reads from r, writes to buf, reads from buf writes to w (concurrently).\r\n\r\n// Buffer 32KB to Memory, discard overflow\r\nbuf = buffer.NewSpill(32*1024, ioutil.Discard)\r\nnio.Copy(w, r, buf)\r\n```\r\n\r\nSupported Buffers\r\n------------\r\n\r\n#### Bounded Buffers ####\r\n\r\nMemory: Wrapper for bytes.Buffer\r\n\r\nFile: File-based buffering. The file never exceeds Cap() in length, no matter how many times its written/read from. It accomplishes this by \"wrapping\" around the fixed max-length file when the data gets too long but there is available freed space at the beginning of the file. The caller is responsible for closing and deleting the file when done.\r\n\r\n```go\r\nimport (\r\n  \"ioutil\"\r\n  \"os\"\r\n  \r\n  \"github.com/djherbis/buffer\"\r\n)\r\n\r\n// Create a File-based Buffer with max size 100MB\r\nfile, err := ioutil.TempFile(\"\", \"buffer\")\r\nif err != nil {\r\n\treturn err\r\n}\r\ndefer os.Remove(file.Name())\r\ndefer file.Close()\r\n\r\nbuf := buffer.NewFile(100*1024*1024, file)\r\n\r\n// A simpler way:\r\npool := NewFilePool(100*1024*1024, \"\") // \"\" -- use temp dir\r\nbuf, err := pool.Get()   // allocate the buffer\r\nif err != nil {\r\n  return err\r\n}\r\ndefer pool.Put(buf) // close and remove the allocated file for the buffer\r\n\r\n```\r\n\r\nMulti: A fixed length linked-list of buffers. Each buffer reads from the next buffer so that all the buffered data is shifted upwards in the list when reading. Writes are always written to the first buffer in the list whose Len() < Cap().\r\n\r\n```go\r\nimport (\r\n  \"github.com/djherbis/buffer\"\r\n)\r\n\r\nmem  := buffer.New(32*1024)\r\nfile := buffer.NewFile(100*1024*1024, someFileObj)) // you'll need to manage Open(), Close() and Delete someFileObj\r\n\r\n// Buffer composed of 32KB of memory, and 100MB of file.\r\nbuf := buffer.NewMulti(mem, file)\r\n```\r\n\r\n#### Unbounded Buffers ####\r\n\r\nPartition: A queue of buffers. Writes always go to the first buffer in the queue which isn't full. If all buffers are full, a new buffer is \"pushed\" to the end of the queue (generated by a user-given function). Reads come from the first buffer, when the first buffer is emptied it is \"popped\" off the queue.\r\n\r\n```go\r\nimport (\r\n  \"github.com/djherbis/buffer\"\r\n)\r\n\r\n// Create 32 KB sized-chunks of memory as needed to expand/contract the buffer size.\r\nbuf := buffer.NewPartition(NewMemPool(32*1024))\r\n\r\n// Create 100 MB sized-chunks of files as needed to expand/contract the buffer size.\r\nbuf = buffer.NewPartition(NewFilePool(100*1024*1024, \"\"))\r\n```\r\n\r\nRing: A single buffer which begins overwriting the oldest buffered data when it reaches its capacity.\r\n\r\n```go\r\nimport (\r\n  \"github.com/djherbis/buffer\"\r\n)\r\n\r\n// Create a File-based Buffer with max size 100MB\r\nfile := buffer.NewFile(100*1024*1024, someFileObj) // you'll need to Open(), Close() and Delete someFileObj.\r\n\r\n// If buffered data exceeds 100MB, overwrite oldest data as new data comes in\r\nbuf := buffer.NewRing(file) // requires BufferAt interface.\r\n```\r\n\r\nSpill: A single buffer which when full, writes the overflow to a given io.Writer.\r\n-> Note that it will actually \"spill\" whenever there is an error while writing, this should only be a \"full\" error.\r\n\r\n```go\r\nimport (\r\n  \"github.com/djherbis/buffer\"\r\n  \"github.com/djherbis/nio\"\r\n  \r\n  \"io/ioutil\"\r\n)\r\n\r\n// Buffer 32KB to Memory, discard overflow\r\nbuf := buffer.NewSpill(32*1024, ioutil.Discard)\r\nnio.Copy(w, r, buf)\r\n```\r\n\r\n#### Empty Buffer ####\r\n\r\nDiscard: Reads always return EOF, writes goto ioutil.Discard.\r\n\r\n```go\r\nimport (\r\n  \"github.com/djherbis/buffer\"\r\n)\r\n\r\n// Reads will return io.EOF, writes will return success (nil error, full write) but no data was written.\r\nbuf := buffer.Discard\r\n```\r\n\r\nCustom Buffers\r\n------------\r\n\r\nFeel free to implement your own buffer, just meet the required interface (Buffer/BufferAt) and compose away!\r\n\r\n```go\r\n\r\n// Buffer Interface used by Multi and Partition\r\ntype Buffer interface {\r\n\tLen() int64\r\n\tCap() int64\r\n\tio.Reader\r\n\tio.Writer\r\n\tReset()\r\n}\r\n\r\n// BufferAt interface used by Ring\r\ntype BufferAt interface {\r\n\tBuffer\r\n\tio.ReaderAt\r\n\tio.WriterAt\r\n}\r\n\r\n```\r\n\r\nInstallation\r\n------------\r\n```sh\r\ngo get github.com/djherbis/buffer\r\n```\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}